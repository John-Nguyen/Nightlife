'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = memoize;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodashLangIsFunction = require('lodash/lang/isFunction');

var _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);

var _lodashCollectionSortBy = require('lodash/collection/sortBy');

var _lodashCollectionSortBy2 = _interopRequireDefault(_lodashCollectionSortBy);

function hashCode_(str) {
  var hash = 0;
  var i = undefined;
  var chr = undefined;
  var len = undefined;
  if (str.length === 0) return hash;
  for (i = 0, len = str.length; i < len; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
}

function log2(val) {
  return Math.log(val) / Math.LN2;
}

function memoize_() {
  var options = arguments[0] === undefined ? {} : arguments[0];

  return function (fn) {
    var _Object$assign = Object.assign({
      cacheSizePower: 8,
      expireMs: 60 * 15 * 1000,
      maxItemsPerHash: 4
    }, options);

    var cacheSizePower = _Object$assign.cacheSizePower;
    var expireMs = _Object$assign.expireMs;
    var maxItemsPerHash = _Object$assign.maxItemsPerHash;
    var cacheSize = _Object$assign.cacheSize;

    var cacheSizePowerCalc = Math.round(cacheSize && cacheSize > 2 ? log2(cacheSize) : cacheSizePower);

    var cacheSizeCalc = Math.pow(2, cacheSizePowerCalc);
    var cache_ = new Array(cacheSizeCalc);
    var mask_ = cacheSizeCalc - 1;

    var peek = function peek(hash, im) {
      if (hash in cache_) {
        var hashArray = cache_[hash];
        var item = hashArray.find(function (v) {
          return v.im === im;
        });
        if (item !== undefined) {
          var currDt = new Date().getTime();
          if (currDt - item.dt < expireMs) {
            return item;
          }

          var index = hashArray.indexOf(item);
          hashArray.splice(index, 1);
        }
      }
    };

    var put = function put(hash, im, result) {
      if (!(hash in cache_)) cache_[hash] = [];
      var hashArray = cache_[hash];
      var currDt = new Date().getTime();

      var item = peek(hash, im);

      if (item !== undefined) {
        item.dt = currDt;
        item.result = result;
        // пересортировать

        cache_[hash] = (0, _lodashCollectionSortBy2['default'])(hashArray, function (v) {
          return v.dt;
        });
      } else {
        item = { dt: currDt, im: im, result: result };

        if (hashArray.length >= maxItemsPerHash) {
          hashArray.shift(); // убрать самый старый элемент
        }
        hashArray.push(item);
      }
    };

    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var im = JSON.stringify(args);
      var hash = hashCode_(im.toString()) & mask_;

      var item = peek(hash, im);

      if (item !== undefined) {
        // есть в кеше вернем
        return new Promise(function (r) {
          return r(item.result);
        });
      }

      return fn.apply(null, args).then(function (r) {
        put(hash, im, r);
        return r;
      });
    };
  };
}

function memoize(optionsOrFn, maybeOptions) {
  if ((0, _lodashLangIsFunction2['default'])(optionsOrFn)) {
    return memoize_(maybeOptions)(optionsOrFn);
  }

  return function (target, key, descriptor) {
    return {
      configurable: true,
      enumerable: true,
      get: function get() {
        var classMethod = typeof descriptor.get !== 'function' ? descriptor.value : descriptor.get.call(this);
        if (typeof classMethod !== 'function') {
          throw new Error('@memoize decorator can only be applied to methods not: ' + typeof classMethod);
        }

        var classMethodBinded = classMethod.bind(this);

        var memoizedCallFn = memoize_(optionsOrFn)(classMethodBinded);

        Object.defineProperty(this, key, {
          value: memoizedCallFn,
          configurable: true,
          writable: true
        });

        return memoizedCallFn;
      }
    };
  };
}

module.exports = exports['default'];